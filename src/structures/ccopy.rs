use crate::structures::{Primes,Point,BaseVector};
use crate::fermat::{FInteger,IntSeq,FIterator};

use crate::{HashTable};
use crate::filter::{StrongFermat,Coprime,GenericFilter};
use std::io::{Read,BufRead,Write};
use crate::compeval::{vector::*,file::*};
use crate::search::{hash_search,unary_ht_par,strip_pseudo_par,strip_pseudo_st,binary_evo_st,binary_det_iter_st,binary_evo_par,binary_evo_st_rand_partial, unary_strongest_st,unary_strongest_par,unary_strongest_rand_par,exhaustive_par,exhaustive_rand_par};
use crate::io::write::format_block;
use crate::result::FResult;
use crate::compconfig::{Search,AUTO_FLAG,UTF8_FLAG,MEMORY_MAX};

 /// CompVector is a structure to handle composites.
 ///
 /// Usually these will be pseudoprimes to some base when generated by this library.
 /// But there is no actual restriction on the value that can be used, even primes can be used, however nearly all 
 /// functions will fail if that is the case.
 ///
 /// CompVector can be either a file or a vector in volatile memory (RAM), but not both. Files are used to hold far more data than 
 /// can be stored in RAM. Preference should be given to using vectors, as this allows much faster evaluation as well 
 /// as allowing it to use all of the same methods as the standard library Vec
 /// 
 /// An explanation of CompVector:
 ///
 /// CompVector is a set of composites with restrictions on how much memory it can use in RAM, as well as a flag that determines whether to read/write
 /// in utf8 or binary format, and another flag that determines whether to automatically load the file contents into RAN which would allow CompVector to 
 /// behave like a standard library Vec. 
 /// 
 /// For simplicity, let's call a CompVector initialised from a Vec to be CVec and one initialised from a file as CFile. This is important because while they share the same methods,
 /// many of the calculations that can be performed on a Vec in RAM are computationally infeasible for files. However files are important to include because you can store far more data
 /// for the calculations that can be performed regardless of the size of the set.
 /// 
 /// Some things to note
 ///
 /// 1. CVec has much of the same functionality as the standard library Vec, as well as being easily parallelisable. This means that it is preferable to load any files to memory if possible.
 ///
 /// 2. CompVector has a flag and a memory_max parameter (accessible via set_auto or set_manual, and set_memory_max respectively), that determines whether or not to load CFile into a CVec
 ///
 /// 3. CompVector is infact configured to do exactly that with a default memory bound of 1 Gibibyte, this can be adjusted by passing the exact number of bytes you want to limit to set_memory_max.
 ///  This means that so long as it is allowed to use enough memory a CFile will infact act like a CVec
 ///
 /// 4. As previously mentioned a CFile will always behave like a CVec so long as enough RAM is available. But if RAM is not available, then it will either return a NotSupported or MemoryExceeded
 ///
 /// 5. Parameters set for one CompVector are inherited by all of the CompVectors calculated from the original. This is done because it's assumed that one would set the memory_max to near the hardware RAM
 /// limit, and the user would likely be interested in writing all files to utf8 or binary. 
 /// 6. CompVectors can be overridden to write to utf-8 or binary with the set_utf8 or set_binary methods. Writing and reading to binary however is the default and the fastest. 
 /// 7. Setting the memory_max to an existing CompVector will not truncate it. However, it will propagate the new memory_max to the new calculated CompVectors
 /// 8. Some functions, particularly the filter_generic functions are able to map to CFile directly without loading the entire CFile to memory. So t
 
 

pub struct CompVector<T: FInteger>{
        // File if used
        file: Option<std::fs::File>,
        // 
        elements: Vec<T>,
        memory_max: u64,
        //
        utf8_flag: bool,
        // Flag to determine if memory is automatically used
        auto_flag: bool 
    }
    
    //  if auto_flag = true then load-to_memory

impl<T: FInteger> Clone for CompVector<T>{

   fn clone(&self) -> Self{
   
    match &self.file{
      Some(filey) => Self{
           file: Some(filey.try_clone().unwrap()),
       elements: self.elements.clone(),
       memory_max: self.memory_max,
       utf8_flag: self.utf8_flag,
       auto_flag: self.auto_flag,
       },
      None => 
         Self{
           file: None,
       elements: self.elements.clone(),
       memory_max: self.memory_max,
       utf8_flag: self.utf8_flag,
       auto_flag: self.auto_flag,
       }
      }
      
    }
     
}

impl<T: FInteger> std::fmt::Display for CompVector<T> {

    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    
      match &self.file{
       Some(_) => {
       
         let mem_est = (self.len()*T::BYTE_LENGTH/3) as u64;
         
         if mem_est > self.memory_max {
           return write!(f,"Stored in file");
         }
         
         match self.load_to_memory(){
               FResult::Value(p) => {
                   let q = format_block::<4,T>(&p.elements);
                   write!(f, "{}", q)
               }
               _ => write!(f,"Memory Exceeded"),
         }
       }
       None => {
        let q = format_block::<4, T>(&self.elements);
        write!(f, "{}", q)
       }
       
      }
   }
}

impl<T: FInteger> CompVector<T>{

  pub fn new() -> Self{
      Self{
      file: None,
      elements: Vec::<T>::new(),
      memory_max: MEMORY_MAX,
      utf8_flag: UTF8_FLAG,
	  auto_flag: AUTO_FLAG
     }
  }
  
  pub fn is_assigned(&self) -> bool{
    match self.file{
      Some(_) => true,
      None => {
        if self.elements.len() > 0{
         return true
        }
        return false
      }
    }
  }
  
  // Returns true if already loaded to memory
  // Returns false if kept in file
  pub fn is_loaded(&self) -> bool{
     match self.file{
      Some(_) => false,
      None => true,
     }
  }
  
  
  pub fn set_file(&mut self,locale: &str){
     if self.is_assigned(){
       panic!("Already assigned a value")
     }
    self.file = Some(std::fs::OpenOptions::new().read(true).write(true).open(locale).unwrap()); 
    
  }
  
  
 /// Set  CompVector to be equal to vector
  pub fn set_vector(&mut self, el: Vec<T>){
     if self.is_assigned(){
       panic!("Already assigned a value")
     }
      self.elements = el;
  }
  
  /// Set to read and write in binary 
  pub fn set_binary(&mut self){
      self.utf8_flag = false;
  }
  
  /// Set to read and write utf-8 format
  pub fn set_utf8(&mut self){
     self.utf8_flag = true;
  }
  
  /// Sets to automatically load any data stored in the file to volatile memory (RAM)
  pub fn set_auto(&mut self){
     self.auto_flag = true;
  }
  
  /// Sets to not load data  
  pub fn set_manual(&mut self){
      self.auto_flag = false;
  }
  
  /// Sets the limit on how large CompVector can be 
  pub fn set_memory_max(&mut self, bound: u64){
          self.memory_max = bound;
  }
  
  /// Number of elements stored in CompVector, this evaluates for CFile as well as CVec
  // FIXME only supports binary files
  pub fn len(&self) -> usize{
      match &self.file{
        Some(x) => (x.metadata().unwrap().len() as usize)/T::BYTE_LENGTH,
        None => self.elements.len(),
      }
  }
  
  pub fn satisfies_memory_bound(&self) -> bool{
      match &self.file{
       Some(x) => {
         let mut len = x.metadata().unwrap().len() as u64;
        
         if self.utf8_flag{
           len /=2;
         }
         
         if self.memory_max < len{
           return false;
         }
         
         return true
       }
       
       None => return true,
      }
  }
  
    /// Initialises from file 
  pub fn from_file(filename : &str) -> FResult<Self>{
	  
	       match std::fs::OpenOptions::new().read(true).write(true).open(filename){
             Ok(x)=> FResult::Value( Self{
				            file: Some(x),
							elements: Vec::<T>::new(),
						  memory_max: MEMORY_MAX,
							utf8_flag: UTF8_FLAG,
							auto_flag: AUTO_FLAG
							}
						  ),
             Err(file_error) => FResult::IOError(file_error) ,
           }
      }
      
  pub fn from_raw_file(f: std::fs::File, mm_flag: u64,u_flag: bool, a_flag:bool) -> Self{
       Self {
                file: Some(f),
            elements: Vec::<T>::new(),
          memory_max: mm_flag, 
           utf8_flag: u_flag,
           auto_flag: a_flag,
           }
  }
  
  pub (crate) fn from_vector_internal(comp: Vec<T>,memory_max: u64, utf8_flag: bool, auto_flag: bool) -> Self{
      Self{
           	  file: None, 
		  elements: comp,
	    memory_max: memory_max,
		 utf8_flag: utf8_flag,
		 auto_flag: auto_flag,
		 }

  }
	  
	/// Initialises from vector  
  pub fn from_vector(comp: Vec<T>) -> Self{
  
      Self::from_vector_internal(comp,MEMORY_MAX,UTF8_FLAG,AUTO_FLAG)
      }
      
 /// Writes to file returning a CompVector handling files   
  // FIXME Map file to file
  pub fn to_file(&self, filename: &str)  -> FResult<Self>{
     
     match std::fs::File::create_new(filename){
     
       Ok(x)=> {
  
           let mut wrtr = std::io::BufWriter::new(x.try_clone().unwrap());
           
         if self.utf8_flag == true{
       
           for i in self.elements.iter(){
              let out_str = i.to_string()+"\n"; 
        
              wrtr.write(out_str.as_bytes()).unwrap();
         }
       }
       
       if self.utf8_flag == false{
       
          for i in self.elements.iter(){
              wrtr.write(&i.to_bytes()[..]).unwrap();
          }
       }
       
       wrtr.flush().unwrap();
       
       return FResult::Value(Self{ 
                      file: Some(x.try_clone().unwrap()),
                  elements: Vec::<T>::new(),
                memory_max: self.memory_max,
                utf8_flag: self.utf8_flag,
                auto_flag: self.auto_flag
                })
     },
             Err(file_error) =>  FResult::IOError(file_error) ,
     }
  }
       

  
  pub fn collect_unique(&self) -> Self{
      let mut ht = std::collections::HashSet::<T>::new();
      for i in self.elements.iter(){
        ht.insert(*i);
      }
      let z = ht.drain().collect::<Vec<T>>();
      Self::from_vector_internal(z,self.memory_max,self.utf8_flag,self.auto_flag)
  }
  
  ///
  pub fn fuse(&mut self, otra: Self){
       for i in otra.elements.iter(){
         self.elements.push(*i);
       }
  }      
      
      
      // FIXME handle file
  pub fn to_vector(&self) -> Vec<T>{
      self.elements.clone()
  }
  
  // FIXME handle other Result values
  pub fn load_eval<K: Clone>(&self, func: &dyn Fn(Self) -> FResult<K>) -> FResult<K>{
      if self.auto_flag && !self.is_loaded(){
        match self.load_to_memory(){
        FResult::MemoryExceeded => FResult::MemoryExceeded,
         FResult::Value(x) => func(x),
         FResult::IOError(error_mssg) =>   FResult::IOError(error_mssg),
         _=> FResult::MemoryExceeded, 
        }
      }
      else if !self.auto_flag && !self.is_loaded(){
         return FResult::NotSupported
      }
      else{
         func(self.clone())
      }
  }
  
  // FIXME handle other Result values
  pub fn load_eval_ref<K: Clone>(&self, func: &dyn Fn(&Self) -> FResult<K>) -> FResult<K>{
      if self.auto_flag && !self.is_loaded(){
        match self.load_to_memory(){
        FResult::MemoryExceeded => FResult::MemoryExceeded,
         FResult::Value(x) => func(&x),
         FResult::IOError(error_mssg) =>   FResult::IOError(error_mssg),
         _=> FResult::MemoryExceeded, 
        }
      }
      else if !self.auto_flag && !self.is_loaded(){
         return FResult::NotSupported
      }
      else{
         func(self)
      }
  }
  
  
  
  // FIXME handle autoloading
  pub fn iter(&self) -> FResult<std::slice::Iter<T>>{
 
      match &self.file{
        Some(_) => FResult::NotSupported,
        None => FResult::Value(self.elements.iter())
      }
  }
  
  
  // FIXME handle file
  pub fn filter_range(&self, inf: T, sup: T) -> Self{
      let mut veccy = vec![];
      
      for i in self.elements.iter(){
        if i.is_bounded_by(inf,sup){
          veccy.push(*i)
        }
      }
      Self::from_vector_internal(veccy,self.memory_max,self.utf8_flag,self.auto_flag)
  }
  
       /// loads file into RAM if possible, this is preferred as it allows much faster datahandling, including parallel evaluation
	   /// # MemoryExceeded
	   /// If file size is greater than 1 GiB, then returns None
	   /// # ReadError
	   /// Unable to read from file
	   /// # FileDNE
	   /// File does not exist
  pub fn load_to_memory(&self) -> FResult<Self>{
  
   match &self.file{
      Some(filey) => {
      
        if !self.satisfies_memory_bound(){
		  return FResult::MemoryExceeded;
	    }
	    
	    let mut r = std::io::BufReader::new(filey.try_clone().unwrap());
	    
	    let mut veccy : Vec<T> = Vec::new();
	    
	     if self.utf8_flag{
	     
	        for i in r.lines(){
	          match i {
	           Ok(x) => {
	               // FIXME handle unwrapping
	              veccy.push(T::from_str(&x).unwrap())
	             
	           }
	           Err(err_message) => return FResult::IOError(err_message),
	          }
	        }
	    
	        return FResult::Value(Self{
           	  file: None, 
		  elements: veccy,
	    memory_max: self.memory_max,
		 utf8_flag: self.utf8_flag,
		 auto_flag: self.auto_flag,
		 });

	     }
	     else{
	     
	       let mut interim = vec![0u8;T::BYTE_LENGTH];
	    
	       loop{
	       
	        match r.read(&mut interim[..]){
	           Ok(totalbytes) => {
	             if totalbytes == 0usize{
	                break;
	             }  
               let num = T::from_bytes(&interim);
               
               veccy.push(num);
	           }
	           Err(err_message) => return FResult::IOError(err_message),
	        }
        }
        return FResult::Value(Self{
           	  file: None, 
		  elements: veccy,
	    memory_max: self.memory_max,
		 utf8_flag: self.utf8_flag,
		 auto_flag: self.auto_flag,
		 });
      }
	  
      },
      None => FResult::FileDNE,
   }

  }    
  
  
  /// Clears all values from CompVector    
  pub fn clear_memory(&mut self){
      self.file = None;
      self.elements.resize(0,T::ZERO);
  }
  
  pub fn write_vector_internal(&mut self, mut output: &std::fs::File){
       use std::io::prelude::*;
       use std::io::SeekFrom;
       
       output.seek(SeekFrom::Start(0));
       let mut wrtr = std::io::BufWriter::new(output);
       
       if self.utf8_flag{
          for i in self.elements.iter(){
            let x = i.to_string()+"\n";
          
            wrtr.write(&x.as_bytes()[..]).unwrap();
          }
          wrtr.flush();
       }
       else if self.utf8_flag == false{
       
       for i in self.elements.iter(){
          wrtr.write(&i.to_bytes()[..]).unwrap();
       }
       wrtr.flush();
       }
  }
  
  
  pub fn mut_vector_op(&mut self, F: &dyn Fn(&mut [T]) -> ())-> FResult<T>{
       match &self.file{
         Some(x) => {
           match self.load_to_memory(){
             FResult::Value(mut interim) => {
            
               F(&mut interim.elements);
              
            interim.write_vector_internal(x);
              
               return FResult::Success;
             }
             FResult::MemoryExceeded => FResult::MemoryExceeded,
             _=> FResult::MemoryExceeded,
           }
         }
         None => {
           F(&mut self.elements);
           return FResult::Success;
         }
       }
  }
  
  pub fn sort(&mut self) -> FResult<T>{
     self.mut_vector_op(&<[T]>::sort)
  }
  
  pub fn reverse(&mut self) -> FResult<T>{
    self.mut_vector_op(&<[T]>::reverse)
  }
 
 // Checks that all values are composite
 pub fn verify(&self) -> FResult<T>{
      for i in self.elements.iter(){
         if i.is_prime(){
           return FResult::ProofFailed;
         }
      }
     FResult::Verified
 }
  
  // FIXME propagate all flags into the return value
  pub(crate) fn filter_generic_internal<F : GenericFilter>(&self, fileout: Option<&str>, filter_flag: bool) -> FResult<Self>{
  
    let mut pseudos : Vec<T> = Vec::new();
    
    match fileout{
     Some(x) =>{
        match std::fs::File::create_new(x){
          Ok(mut output) => {
             if self.elements.len() > 0{
              let pseudos = filter_generic_v::<T,F>(&self.elements);
              // FIXME catch write error
             for i in pseudos{
                 output.write(&i.to_bytes()[..]).unwrap();
             }
           }
           
          else{
             filter_generic_file::<T,F>(self.file.as_ref().unwrap().try_clone().unwrap(),output.try_clone().unwrap(),self.utf8_flag,true);
          }
          return FResult::Value(Self::from_raw_file(output.try_clone().unwrap(),self.memory_max,self.utf8_flag,self.auto_flag))
          }
          
          Err(file_error) => FResult::IOError(file_error),
        }
     }
     None => {
             let mut pseudos : Vec<T> = Vec::new();
             if self.elements.len() > 0{
                 pseudos = filter_generic_v::<T,F>(&self.elements);
             }
             else{
                let infile = self.file.as_ref().unwrap().try_clone().unwrap();
                pseudos = filter_generic::<T,F>(infile,self.utf8_flag,true);
             }
           return FResult::Value(Self::from_vector_internal(pseudos,self.memory_max,self.utf8_flag,self.auto_flag));
          }
  }
 }
 
  /// Applies a filter that implements the GenericFilter trait
  pub fn filter_generic<F: GenericFilter>(&self, filename: Option<&str>) -> FResult<Self> {
      self.filter_generic_internal::<F>(filename,true)
  }
  
  pub fn nfilter_generic<F: GenericFilter>(&self, filename: Option<&str>) -> FResult<Self> {
      self.filter_generic_internal::<F>(filename,false)
  }
  
  /// Filters all composites that fail a compile-time defined check that implements GenericFilter and StrongFermat
  pub fn filter_sprp<F: StrongFermat>(&self, filename: Option<&str>) -> FResult<Self> {
      self.filter_generic_internal::<F>(filename,true)
  }
  
  pub fn nfilter_sprp<F: StrongFermat>(&self, filename: Option<&str>) -> FResult<Self> {
      self.filter_generic_internal::<F>(filename,false)
  }
  
  pub fn filter_coprime<F: Coprime>(&self, filename: Option<&str>) -> FResult<Self> {
      self.filter_generic_internal::<F>(filename,true)
  }
  
  pub fn nfilter_coprime<F: Coprime>(&self, filename: Option<&str>) -> FResult<Self> {
      self.filter_generic_internal::<F>(filename,false)
  }
  
  /// Attempts to construct a hashtable of fermat bases with the provided arguments (size, hash multiplier, and fermat base maximum) or use defaults.  
    /// Note that providing the same integer parameters for the same set results in identical tables being produced, 
    /// allowing reproducibility. 
    /// Variation is primarily determined by the multiplier value which is pseudorandomly generated if not provided. 
    /// For instance to_hashtable(None,Some(3411698987), None) will always produce the same table for the same composite set
    /// as the dimension is computed as a ratio of the length and the base maximum is 65535 by default
    pub fn to_hashtable(&self, dimen: Option<usize>, multiplier: Option<u32>,bound: Option<u64>) -> FResult<HashTable> {
        // If dimension of hashtable defined use it, otherwise calculate it 
        let dim = if let Some(dm) = dimen {
              dm
            } else {
            (self.elements.len()/150).next_power_of_two()
        };
       
        // If multiplier defined use it, otherwise calculate it
        let mul = if let Some(mx) = multiplier {
              mx
            } else {
            let iterations = 262144000/self.elements.len();
            hash_search(&self.elements[..], dim, iterations)
        };
        
        // If multiplier defined use it, otherwise set it as 65535
        let bnd = if let Some(bd) = bound {
              bd
            } else {
            65535
        };
        
        match unary_ht_par::<T,1>(self.elements.clone(), dim, mul, bnd) {
            FResult::Exhaustive(x) => FResult::Exhaustive(HashTable::new(x, dim, mul)),
            FResult::InsufficientCandidates(x) => FResult::InsufficientCandidates(x),
                                           _=> FResult::InsufficientCandidates(0),
        }
    }
    
    
    /// FIXME Bound for 256
    pub fn compute_hashtable(&self, dimen: Option<usize>, multiplier: Option<u32>,bound: Option<u64>) -> FResult<HashTable> {
       
       match dimen{
         Some(x) => {
           loop {
             match self.to_hashtable(Some(x),multiplier,bound){
               FResult::Exhaustive(res) => return FResult::Exhaustive(res),
               _=> {()},
             }
           }
         }
         
         None => {
         
            let mut dm = (self.elements.len()/600).next_power_of_two();
            
            loop {
              match self.to_hashtable(Some(dm),multiplier,bound){
                FResult::Exhaustive(res) => return FResult::Exhaustive(res),
                FResult::InsufficientCandidates(c_count) => {
                   if c_count == 0{
                     dm*=2;
                   }
                   else if dm/c_count > 2{
                      dm*=2;
                   }
               }
               _=> (),
            } // end inner match
         } // end loop 
       } // end middle match
    } // end dimen match
    
    }
    
    
    /// Filters the composites using a BaseVector
    pub fn filter_bvector(&self, fil: &BaseVector<T>) -> Self{
     
        let mut ce = self.clone();
    
        for i in fil.iter(){
           ce = ce.sprp_ce(*i);
        }
      ce
    }
    
    /// Filters the composites using a Hashtable
    pub fn filter_hashtable(&self, ht: &HashTable) -> Self{
        let mut veccy = vec![];
        for i in self.iter().unwrap(){
           if ht.primality(*i){
              veccy.push(*i);
           }
        }
        Self::from_vector_internal(veccy,self.memory_max,self.utf8_flag,self.auto_flag)
    }
    
    
    /// Filter by a selected base, collecting all composites that pass
    /// # Usage
    /// This is the run-time equivalent to filter_sprp
    pub fn sprp_ce(&self, base: T) -> Self{
    
       match self.file{
         Some(_) => {
           let ce = filter_strong::<T>(self.file.as_ref().unwrap().try_clone().unwrap(),self.utf8_flag,true,base);
           Self::from_vector_internal(ce,self.memory_max,self.utf8_flag,self.auto_flag)
         }
         None => {
          let mut ce = self.elements.clone();
           if ce.len() > 1000{
            ce= strip_pseudo_st::<T>(&ce[..],base);
                }
           else{     
         ce= strip_pseudo_par::<T>(ce,base);
         }
        Self::from_vector_internal(ce,self.memory_max,self.utf8_flag,self.auto_flag)
         }
       } // match 
        
    }
    
    // 206,168,204,188,165,211 10_000
    // 205,208,158,203,208         100_000 
    // 182,173,181,210,            
     // FIXME account for k < 3
    pub fn k_base(&self, k: usize) -> BaseVector<T>{
       let mut bv = BaseVector::rand_initialise(k-2);
       bv.append(T::ONE);
       bv.append(T::ONE);
       let mut ce = self.filter_bvector(&bv); 
       // swap all elements with probably stronger ones
       for j in 0..2{
       
            //bv.swap(T::ONE,k-j*2);
            //bv.swap(T::ONE,k-j*2+1);
      
           // ce = self.filter_fbase(&bv); 
       bv.swap(T::ZERO,j*2);
       bv.swap(T::ZERO,j*2+1);
      
       for i in 0..(k/2){
       
        // let (x,y) = binary_evo_st_rand_partial::<T>(&ce.elements[..],3,20_000);//binary_evo_st::<T>(&ce.elements[..],3,10_000);
        let (x,y) = binary_evo_st::<T>(&ce.elements[..],3,100_000);
       
         bv.swap(T::from_u64(x),i*2);
         bv.swap(T::from_u64(y),i*2+1);
         ce = self.filter_bvector(&bv);
      
       }
     //}
      // let (x,y) = binary_evo_st::<T>(&ce.elements[..],3,10_000);
      // bv.append(T::from_u64(x));
      // bv.append(T::from_u64(y));
       } 
       bv.swap(T::ONE,k-1);
       bv.swap(T::ONE,k-2);
      
       let fin = self.filter_bvector(&bv);// unary_strongest_st
       let (sec,_) = unary_strongest_par(fin.elements,3,1_000_000);
       bv.swap(T::from_u64(sec),k-2);
       let fin2 = self.filter_bvector(&bv);
       
       let strong = exhaustive_par(fin2.elements);//unary_strongest_st(&fin.elements[..],3,1_000_000);
       bv.swap(T::from_u64(strong),k-1);
       bv
    }
    
  pub fn k_evo(&self, k: usize) -> BaseVector<T>{
      let mut bv = BaseVector::rand_initialise(k-1);
      let mut ce = self.filter_bvector(&bv);
      
      for i in 0..(k-1)/2{
         let (x,y) = binary_det_iter_st::<T,IntSeq<T>>(&ce.elements[..],IntSeq::<T>::new(Some(T::from_u64(2)),1000).unwrap());
       
         bv.swap(x,i*2);
         bv.swap(y,i*2+1);
         ce = self.filter_bvector(&bv);
      //
      }
      let x = exhaustive_par(ce.elements);
      //let (x,y) = binary_evo_par::<T>(ce.elements,3,100_000);
      bv.append(T::from_u64(x));
      //bv.append(T::from_u64(y));
      bv
  }
  
  pub fn k_iterative(&self, k: usize) -> BaseVector<T>{
      let mut ce = self.clone();
      let mut bv = BaseVector::<T>::new(vec![]);
      for i in 0..(k-1){
       let bound = 1_000;
         let (c,_) = unary_strongest_par::<T>(ce.elements.clone(),3,bound*(k as u64+1));
         ce = ce.sprp_ce(T::from_u64(c));
         bv.append(T::from_u64(c));
      }
      let x = exhaustive_par(ce.elements);
      bv.append(T::from_u64(x));
      bv
  }
  
  /// Infinite search, this is short-circuiting and therefore much faster than a strongest search. However it has an unpredictable run time
  pub fn terminating_search(&self) -> FResult<BaseVector<T>>{
     self.load_eval(&|x: Self| FResult::Value(BaseVector::new(vec![T::from_u64(exhaustive_par(x.elements))])))
  }
  
  pub fn iterative_search(&self) -> BaseVector<T>{
      let mut ce = self.clone();
      let mut bv = BaseVector::<T>::new(vec![]);
      
      while ce.len() > 100{
        let bound = 10_000_000_000u64/(ce.len() as u64);
        let (c,_) = unary_strongest_par::<T>(ce.elements.clone(),3,bound);
         ce = ce.sprp_ce(T::from_u64(c));
         bv.append(T::from_u64(c));
      }
      
      let x = exhaustive_par(ce.elements);
      bv.append(T::from_u64(x));
      bv
  }
  
  /// Searches for the strongest base within an interval
  pub fn strongest_search(&self, inf: u64,sup: u64) -> FResult<Point<u64>>{
     self.load_eval(&|x: Self| {
         let (base, count) = unary_strongest_par::<T>(x.elements,inf,sup);
         FResult::Value(Point::<u64>::new(base,count))
     })
        }
  
  pub fn bs_rand(&self) -> BaseVector<T>{
      let b = T::gen_k(64).unwrap();
      let mut bv = BaseVector::new(vec![b]);
      let mut ce =  self.sprp_ce(b);
      
      while ce.len() > 0{
        let b = T::gen_k(64).unwrap();
        ce = ce.sprp_ce(b);
        bv.append(b);
      }
      bv
  }
  /*
  pub fn k_2(&self, k: usize) -> BaseVector<T>{
      let mut bv = FBase::rand_initialise(k-1);
      let mut ce = self.filter_fbase(&bv);
      
      let mut strong_count = ce.len();
      let mut strong_bv = bv.clone();
      //println!("Start {}",ce.element_count());
      
      for i in 0..(k-1){
         let (new_base,_) = unary_strongest_rand_par(ce.elements,50_000);//unary_strongest_par(ce.elements,3,100_000);
         bv.swap(T::from_u64(new_base),i);
         ce = self.filter_fbase(&bv);
         if ce.len() < strong_count{
           strong_bv = bv.clone();
           strong_count = ce.len();
         }
    
      }
      // swap base vector with strongest found by earlier search
      bv = strong_bv.clone();
      let mut bvcopy = bv.clone();
     
      bv.swap(T::ONE,0);
      bv.swap(T::ONE,1);
      
      ce = self.filter_fbase(&bv);
      
      let (x,y) = binary_evo_par(ce.elements,3,100_000);
      
      bv.swap(T::from_u64(x),0);
      bv.swap(T::from_u64(y),1);
            ce = self.filter_fbase(&bv);
      /*
      for i in 0..(k-1){
         bv.swap(T::ONE,i);
         ce = self.filter_fbase(&bv);
         //let (new_base,_) = unary_strongest_rand_par(ce.elements,25_000);//
         let (new_base,_) = unary_strongest_par(ce.elements,3,1_000_000);
         bv.swap(T::from_u64(new_base),i);
         ce = self.filter_fbase(&bv);
         if ce.len() < strong_count{
           strong_bv = bv.clone();
           strong_count = ce.len();
         }
                
      }
            bv = strong_bv.clone();
        
      for i in 0..(k-1){
         bv.swap(T::ONE,i);
         ce = self.filter_fbase(&bv);
         //let (new_base,_) = unary_strongest_rand_par(ce.elements,250_000);
         let (new_base,_) = unary_strongest_par(ce.elements,3,1_000_000);
         bv.swap(T::from_u64(new_base),i);
         ce = self.filter_fbase(&bv);

      }
      */
     
      
      
       bvcopy.swap(T::ONE,2);
      bvcopy.swap(T::ONE,3);
      
      let mut ce2 = self.filter_fbase(&bvcopy);
      
      let (x,y) = binary_evo_par(ce2.elements,3,100_000);
      
      bvcopy.swap(T::from_u64(x),2);
      bvcopy.swap(T::from_u64(y),3);
            ce2 = self.filter_fbase(&bvcopy);
     
      let fin = exhaustive_par(ce.elements);//(fin,_) = unary_strongest_par(ce.elements,3,100_000_000);
      bv.append(T::from_u64(fin));
      bv
  }  
  
 pub fn k_3(&self, k: usize) -> FBase<T>{
     let mut bv = FBase::rand_initialise(k);
     let mut ce = self.filter_fbase(&bv);
     let mut strong_bv = bv.clone();
     let mut strong_count = ce.len() as u64;
    
     loop {
     //if strong_count > 150{
     //   break;
     //}
     if strong_count == 0{
        break;
     }
     for i in 0..(k-1){
        let og_base = bv.swap(T::ONE,i).unwrap();
        ce = self.filter_fbase(&bv);
        let (new_base,_) = unary_strongest_rand_par(ce.elements,250_000);
        bv.swap(T::from_u64(new_base),i);
        ce = self.filter_fbase(&bv);
        let count = ce.len() as u64;
        
        if count < strong_count{
           strong_bv = bv.clone();
           strong_count = count;
        
        }
        if count >= strong_count{
           bv.swap(og_base,i);
        }
        if strong_count == 0{
          break;
        }
     }
     //if strong_count < 40{
     //   break;
    // }
     }
    // strong_bv.swap(T::ONE,0);
     //ce = self.filter_fbase(&strong_bv);
      //let fin = exhaustive_par(ce.elements);
      //strong_bv.swap(T::from_u64(fin),0);
      
      //strong_bv.append(T::from_u64(fin));
     strong_bv
  }
  
  pub fn k_4(&self, k: usize) -> FBase<T>{
     let mut bv = FBase::rand_initialise(k-1);
     let mut ce = self.filter_fbase(&bv);
     let mut strong_bv = bv.clone();
     let mut strong_count = ce.len() as u64;
    loop{
      bv = FBase::rand_initialise(k-1);
      ce = self.filter_fbase(&bv);
      let count = ce.len() as u64;
       if count < strong_count{
           strong_bv = bv.clone();
           strong_count = count;
        }
      if count < 300{
        return bv
      }  
    }
    }
  */ 
   // [39015, 51597, 42143, 25722, 11393194283127744416]
  pub fn k_5(&self, k: usize) -> BaseVector<T>{
    let mut bv = BaseVector::rand_initialise(k-1);
    let mut ce = self.filter_bvector(&bv);
    let mut strong_bv = bv.clone();
    let mut strong_count = ce.len();
    let mut first_loop = true;
    loop {
    
      if strong_count < 100{
         break;
      }
      
    for i in 0..(k-1){
        bv.swap(T::ONE,i);
        ce = self.filter_bvector(&bv);
        let mut new_base = 0u64;
        if first_loop{
          new_base = unary_strongest_par(ce.elements.clone(),3,100_000).0;
         }
         else{
          new_base = unary_strongest_par(ce.elements.clone(),3,1_000_000).0;
         }
   
        bv.swap(T::from_u64(new_base),i);
         ce = self.filter_bvector(&bv);
         
         if ce.len() < strong_count{
           strong_bv = bv.clone();
           strong_count = ce.len();
        
         }
    }
    first_loop = false;
    }
    
     ce = self.filter_bvector(&bv);
    
     let last_base = exhaustive_par(ce.elements);
     strong_bv.append(T::from_u64(last_base));
     strong_bv
  }  
  
  
  pub fn k_rand(&self, k : usize) -> BaseVector<T>{
    loop{
       
       let bv = BaseVector::<T>::rand_initialise(k);
       let ce = self.filter_bvector(&bv);
       if ce.len() == 0{
          return bv
       }
       }
  }
  /*
  pub fn filter_fermat<F: WeakFermat>(&self) -> Self {
      
  }
  
  pub fn nfilter_fermat<F: WeakFermat>(&self) -> Self {
      
  }
  
  pub fn filter_eulerfermat<F: EulerFermat>(&self) -> Self {
      
  }
  
  pub fn nfilter_eulerfermat<F: EulerFermat>(&self) -> Self {
  
  }
  */
 
  // Generates a set of bases of k-length that eliminate all the composites stored
  // Algorithm 
  // Generate k-2 bases
  // Search the strongest pair for the last two
  // Swap previous bases with the two found 
 // pub fn k_base(&self, k: usize) -> Fbase<u64>

}
